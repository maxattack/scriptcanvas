import os
import os.path
import sys

modules = {

	'scene': {
		'paint': 			'void SceneSystem::Paint()',
		'nodeCount': 		'int SceneSystem::NodeCount()',
		'createNode': 		'ID SceneSystem::CreateNode(ID parent=0)',
		'attachTo': 		'void SceneSystem::AttachNode(ID parent, ID child)',
		'detach': 			'void SceneSystem::Detach(ID child)',
		'parent': 			'ID SceneSystem::Parent(ID node)',
		'destroyNode':		'void SceneSystem::DestroyNode(ID node)',
		'position': 		'float2 SceneSystem::Position(ID node)',
		'rotation': 		'float SceneSystem::Rotation(ID node)',
		'direction': 		'float2 SceneSystem::Direction(ID node)',
		'setPosition': 		'void SceneSystem::SetPosition(ID node, float2 pos)',
		'setRotation': 		'void SceneSystem::SetRotation(ID node, float degrees)',
		'setDirection': 	'void SceneSystem::SetDirection(ID node, float2 dir)'
	},

	'circle': {
		'create':			'void CircleSystem::Create(ID node, color_t color, float radius)',
		'destroy': 			'void CircleSystem::Destroy(ID node)',
		'fill': 			'color_t CircleSystem::Fill(ID node)',
		'radius': 			'float CircleSystem::Radius(float radius)',
		'setFill': 			'void CircleSystem::SetFill(ID node, color_t fill)',
		'setRadius': 		'void CircleSystem::SetRadius(ID node, float radius)'
	},

	'input': {
		'mousePosition': 	'float2 InputSystem::MousePosition()',
		'seconds': 			'double InputSystem::Time()'
	},

	'spline': {
		'addMaterial':		'ID SplineSystem::CreateMaterial(float weight, color_t color)',
		'weight':			'float SplineSystem::Weight(ID node)',
		'color':			'color_t SplineSystem::Color(ID mat)',
		'setWeight':		'void SplineSystem::SetWeight(ID mat, float weight)',
		'setColor':			'void SplineSystem::SetColor(ID mat, color_t color)',
		'addSegment':		'ID SplineSystem::CreateHermiteSegment(ID start, ID end, ID mat)'
	}

}

def main():
	with open(sys.argv[1], 'w') as src:
		src.write('#include "ScriptSystem.h"\n')
		src.write("// GENERATED BY WRITE_BINDINGS.PY, DO NO MODIFY BY HAND\n\n")
		write_function_implementation(src, 'scene', 'paint', 'void SceneSystem::Paint()')
		src.write('void ScriptSystem::Bind(lua_State* L) {\n')
		write_function_registration(src, 'scene', 'paint')
		src.write('}\n\n')


def write_function_implementation(src, module, name, sig):
	result_type, command, args = unpack_signature(sig)
	src.write('static int syscall_%s_%s(lua_State* L) {\n' % (module, name))
	# gather arguments (if DEBUG check types)
	if args:
		fail("TODO: gather args from lua stack")
	else:
		# TODO: validate no args
		pass
	# alloc result
	if result_type != 'void':
		fail("TODO: alloc return")
	# invoke function
	src.write("\t")
	src.write(command)
	src.write("(")
	# pass arguments
	if args:
		fail("TODO: pass args")
	src.write(");\n")
	# push results
	num_results = 0
	if args:
		fail("TODO: push args on lua stack")
	src.write("\treturn %d;\n"  % num_results)
	src.write("}\n\n")

def write_function_registration(src, module, name):
	src.write('\tlua_pushcfunction(L, syscall_%s_%s);\n' % (module, name))
	src.write('\tlua_setglobal(L, "%s");\n' % name)


def unpack_signature(sig):
	# parse the signature string
	# TODO: check validity?
	first_space = sig.find(' ')
	first_paren = sig.find('(')
	last_paren = sig.rfind(')')
	return_value = sig[0:first_space]
	name = sig[first_space+1:first_paren]
	arg_sig = sig[first_paren+1:last_paren].strip()
	tokens = ( arg.strip() for arg in arg_sig.split(',') if arg.strip() )
	def unpack_arg_token(sig):
		first_space = sig.find(' ')
		type = sig[0:first_space].strip()
		name = sig[first_space+1:].strip()
		if '=' in name:
			idx = name.find('=')
			actual_name = name[0:idx].strip()
			default_value = name[idx+1:].strip()
			return (type,actual_name,default_value)
		else:
			return (type,name,None)
	args = tuple( unpack_arg_token(token) for token in tokens )
	return (return_value, name, args)

def fail(msg):
	print msg
	exit(-1)

if __name__ == '__main__':
	if len(sys.argv) < 2:
		print "usage: write_bindings [output.cpp]"
		exit(-1)
	main()


