import os
import os.path
import sys

_MODULES = {

	'scene': {
		'paint': 			'void SceneSystem::Paint()',
		'nodeCount': 		'int SceneSystem::NodeCount()',
		'createNode': 		'ID SceneSystem::CreateNode(ID parent=0)',
		'attachTo': 		'void SceneSystem::AttachNode(ID parent, ID child)',
		'detach': 			'void SceneSystem::Detach(ID child)',
		'parent': 			'ID SceneSystem::Parent(ID node)',
		'destroyNode':		'void SceneSystem::DestroyNode(ID node)',
		'position': 		'float2 SceneSystem::Position(ID node)',
		'rotation': 		'float SceneSystem::Rotation(ID node)',
		'direction': 		'float2 SceneSystem::Direction(ID node)',
		'setPosition': 		'void SceneSystem::SetPosition(ID node, float2 pos)',
		'setRotation': 		'void SceneSystem::SetRotation(ID node, float degrees)',
		'setDirection': 	'void SceneSystem::SetDirection(ID node, float2 dir)'
	},

	'circle': {
		'create':			'void CircleSystem::Create(ID node, color_t color, float radius)',
		'destroy': 			'void CircleSystem::Destroy(ID node)',
		'fill': 			'color_t CircleSystem::Fill(ID node)',
		'radius': 			'float CircleSystem::Radius(float radius)',
		'setFill': 			'void CircleSystem::SetFill(ID node, color_t fill)',
		'setRadius': 		'void CircleSystem::SetRadius(ID node, float radius)'
	},

	'input': {
		'mousePosition': 	'float2 InputSystem::MousePosition()',
		'seconds': 			'double InputSystem::Time()'
	},

	'spline': {
		'addMaterial':		'ID SplineSystem::CreateMaterial(float weight, color_t color)',
		'weight':			'float SplineSystem::Weight(ID node)',
		'color':			'color_t SplineSystem::Color(ID mat)',
		'setWeight':		'void SplineSystem::SetWeight(ID mat, float weight)',
		'setColor':			'void SplineSystem::SetColor(ID mat, color_t color)',
		'addSegment':		'ID SplineSystem::CreateHermiteSegment(ID start, ID end, ID mat)'
	}

}

MODULES = {
	'scene': {
		'paint':	'void SceneSystem::Paint()'		
	}
}

HEADER = '''#include "ScriptSystem.h"
// GENERATED BY "tools/write_bindings.py"
// DO NOT MODIFY BY HAND

namespace ScriptSystem {
namespace Internal {

static void LoadModule(lua_State* L, const char* name, const luaL_Reg *p) {
	lua_newtable(L);
	while(p->name) {
		lua_pushstring(L, p->name);
		lua_pushcfunction(L, p->func);
		lua_settable(L, -3);
		++p;
	}
	lua_setglobal(L, name);
}

'''

def main():
	with open(sys.argv[1], 'w') as src:
		src.write(HEADER)
		for module, signatures in MODULES.iteritems():
			for name,sig in signatures.iteritems():
				write_function_implementation(src, module, name, sig)
			src.write("static const luaL_Reg _%s[] = {\n" % module)
			for name in signatures:
				write_line(src, '{ "%s", _%s_%s  },' % (name, module, name))
			write_line(src, '{ NULL, NULL }')
			src.write("};\n\n")
		src.write("}\n\n")
		src.write('void Bind(lua_State* L) {\n')
		for module in MODULES:
			#write_line(src, 'luaL_newlib(L, %s);' % module)
			write_line(src, 'Internal::LoadModule(L, "%s", Internal::_%s);' % (module, module))
		src.write('}\n\n}\n\n')


def write_function_implementation(src, module, name, sig):
	result_type, command, args = unpack_signature(sig)
	src.write('static int _%s_%s(lua_State* L) {\n' % (module, name))
	# gather arguments (if DEBUG check types)
	if args:
		fail("TODO: gather args from lua stack")
	else:
		# TODO: validate no args
		pass
	# alloc result
	if result_type != 'void':
		fail("TODO: alloc return")
	# invoke function
	src.write("\t")
	src.write(command)
	src.write("(")
	# pass arguments
	if args:
		fail("TODO: pass args")
	src.write(");\n")
	# push results
	num_results = 0
	if args:
		fail("TODO: push args on lua stack")
	src.write("\treturn %d;\n"  % num_results)
	src.write("}\n\n")

def write_line(src, line):
	src.write('\t')
	src.write(line)
	src.write('\n')


def unpack_signature(sig):
	# parse the signature string
	# TODO: check validity?
	first_space = sig.find(' ')
	first_paren = sig.find('(')
	last_paren = sig.rfind(')')
	return_value = sig[0:first_space]
	name = sig[first_space+1:first_paren]
	arg_sig = sig[first_paren+1:last_paren].strip()
	tokens = ( arg.strip() for arg in arg_sig.split(',') if arg.strip() )
	def unpack_arg_token(sig):
		first_space = sig.find(' ')
		type = sig[0:first_space].strip()
		name = sig[first_space+1:].strip()
		if '=' in name:
			idx = name.find('=')
			actual_name = name[0:idx].strip()
			default_value = name[idx+1:].strip()
			return (type,actual_name,default_value)
		else:
			return (type,name,None)
	args = tuple( unpack_arg_token(token) for token in tokens )
	return (return_value, name, args)

def fail(msg):
	print msg
	exit(-1)

if __name__ == '__main__':
	if len(sys.argv) < 2:
		print "usage: write_bindings [output.cpp]"
		exit(-1)
	main()


